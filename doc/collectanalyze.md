# Collect and Analyze

If you wish to examine the arguments to the functions present in the
stack backtrace, you need to do three things while the exception is
still present in `*e`:

  * `(collect)`
  * reproduce the exception
  * `(analyze)`

## Collect

Collect will "hook" all of the functions for which zpst can find
source in the stack backtrace.  In addition to collecting the arguments
to each of these functions, it will also capture all of the thread-local
bindings at each function invocation.  It will also capture all of the
var redefinitions for every namespace explicitly specified by the
user.  These namespaces are specified by:

```clojure
{:ns '[<ns-1> <ns-2> ... <ns-n>]}
```
You don't have to specify individual vars, but you do have to specify
namespaces.  Th is is __only__ necessary if you wish to use the 
`(re-eval)` capability to initiate a call from any frame in the
database __and__ if any of the functions on the stack have actually
redefined any vars.  One hint that things might have been redefined is
any use of `clojure.core/with-redefs` or `clojure.core/with-redefs-fn`.

The default value for `:ns` is `{:ns '[zprint.zfns]}` which covers
the functions uthat are redefined in the zprint library (from which
the example was drawn).  If you wish to experiment with recreating
the example in the overview, you can do so without having to figure
out that zprint redefines some of the vars in the `zprint.zfns` 
namespace.  You will want to replace this value if you want to
use `(re-eval)` with your own code that redefines vars.

Once you have run `collect`, you should reproduce the exception and
then immediately run `analyze` to gather the data from the exception
and to "unhook" the functions.

## Analyze

Analyze will take the exception generated by reproducing the
exception and turn the information in that exception into a
database of frames that the 
[commands](commands.md "") will operate on.

It will also "unhook" all of the functions that `collect` hooked.

